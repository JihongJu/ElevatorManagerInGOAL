init module{
	knowledge{
		
		% auction
		auction(Level, Dir) :- fButtonOn(Level,Dir), not(served(Level,Dir)).
		
		% agent X bids higher than agent Y
		higherThan(X, Y, Level, Dir) :- bid(X, Level, Dir, UtilX), bid(Y, Level, Dir, UtilY), X\=Y, UtilX>UtilY, agent(X), agent(Y).
		% exist a bid higher than bid (X, Level,Dir,UtilX))
		existHigherThan(X, Level,Dir,UtilX) :- bid(X, Level, Dir, UtilX), higherThan(_,X,Level,Dir).
		% there does not exist a bid higher than the highest bid
		highest_bid(X, Level,Dir,UtilX) :- auction(Level, Dir), bid(X, Level, Dir, UtilX), not(existHigherThan(X, Level, Dir, UtilX)).
		
		% exist a bid for the auction
		existABid(Level, Dir) :- auction(Level, Dir), bid(AnyAgt, Level, Dir, AnyUtil).
		
		% exists one agent not send bidding request
%		notAllReqSent(Level, Dir) :- auction(Level, Dir), agent(Agt), not(me(Agt)), not(requestSent(Agt, Level, Dir)).
		
		% exists one agent not bid
		notAllBid(Level, Dir) :- auction(Level, Dir), agent(Agt), not(me(Agt)), not(hasBid(Agt, Level, Dir)).
		
		% Count current number of tasks
		hasSameBid(Level, Dir) :- aggregate_all(count, bid(_,Level,Dir,Util), Count), Count \= 1.
		
		% set agent priority for task assignment
		%% choose(List, Elt) - chooses a random element
		%% in List and unifies it with Elt.
		selectAgt([], []).
		selectAgt(List, Elt) :- length(List, Length), random(0, Length, Index), nth0(Index, List, Elt).
		

		
		
	}
	beliefs{
		atFloor(1).
		dir(down).
		served(1,down).
		
	}
	goals{
				
	}
}

main module{
	program {
		
		

	}
}

event module {
	program {
		%%%%% Communicating Processing %%%%%
		
		% receive elevators' identities
%		forall bel( received(Sender, agent(Sender)) )
%			do insert( agent(Sender) ).
		
		% update beliefs from elevator agents' percepts
		%%%%%%%%%%%%%%%%%%%%%%%%%%%% not used by now
		
		% insert or delete "Level Floor's Dir button is on" when received from elevator agents.
		forall bel( received(Sender, fButtonOn(Level,Dir)) )
			do insert( fButtonOn(Level,Dir) )
			+ delete( received(Sender, fButtonOn(Level,Dir)) ).	% delete received messages 
			
		forall bel(  received(Sender, not(fButtonOn(Level,Dir))) )
			do delete( fButtonOn(Level,Dir) )
			+ delete( received(Sender, not(fButtonOn(Level,Dir))) )	% delete received messages
			+ delete( served(Level, Dir) ).
		
			
		%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Bids Management
		% send auction. requestSent help manage bidding request and hasbid help handle response from the elevators
		forall bel( agent(Receiver), not(me(Receiver)), auction(Level, Dir), not(requestSent(Receiver, Level, Dir)), not(hasBid(Sender, Level, Dir) ) )
			do (Receiver).sendonce(please_bid(Level,Dir))
			+ insert( requestSent(Receiver, Level, Dir) )
			+ delete( sent(Receiver, please_bid(Level,Dir)) ).
		
		% send the auction for another time if all the elevators bid with Util less than or equal to 0
		forall bel( highest_bid(Agt, Level, Dir, Util), bid(Agt, Level, Dir, Util), Util =< 0, not(notAllBid(Level,Dir)),  agent(Receiver), not(me(Receiver)), not(served(Level, Dir)) )
			do (Receiver).sendonce(please_bid_once_again(Level,Dir))
			+ insert( requestSent(Receiver, Level, Dir) )
			+ delete( sent(Receiver, please_bid_once_again(Level,Dir)) ).
		
		% delete served information if received continue the auction command from the elevators
		forall bel( received(Sender, contd(Level, Dir)) )
			do delete( served(Level, Dir) )
			+ delete( received(Sender, contd(Level, Dir)) ).

		
		%%%%% receive bids
		
		%%%%% hasbid help the manager check if all the elevators bid. Only when all the elevator bid will the manager assign the task to the one who bid highest.
		
		% accept the first bid for an auction
		forall bel( received(Sender, bid(Level, Dir, Util)), auction(Level, Dir), not(existABid(Level,Dir)), not(me(Sender)) )
			do delete( received(Sender, bid(Level, Dir, Util)) )
			+ insert( bid(Sender, Level, Dir, Util) )
			+ insert( hasBid(Sender, Level, Dir) )
			+ delete( requestSent(Sender, Level, Dir) ).
			
		% accept bid with different utility from the previous one
		forall bel( received(Sender, bid(Level, Dir, Util)), auction(Level, Dir), bid(OtherSender, Level, Dir, OtherUtil), 
				Util \= OtherUtil, not(me(Sender)) )
			do delete( received(Sender, bid(Level, Dir, Util)) )
			+ insert( bid(Sender, Level, Dir, Util) )
			+ insert( hasBid(Sender, Level, Dir) )
			+ delete( requestSent(Sender, Level, Dir) ).

		% reject bid with the same utility as the previous one
		forall bel( received(Sender, bid(Level, Dir, Util)), auction(Level, Dir), bid(OtherSender, Level, Dir, OtherUtil), Util = OtherUtil, not(me(Sender)) )
			do delete( received(Sender, bid(Level, Dir, Util)) )
			+ insert( hasBid(Sender, Level, Dir) )
			+ delete( requestSent(Sender, Level, Dir) ).
		
		% reject bid when auction has been closed
		forall bel( received(Sender, bid(Level, Dir, Util)), not(auction(Level, Dir)) )
			do delete( received(Sender, bid(Level, Dir, Util)) )
			+ delete( requestSent(Sender, Level, Dir) ).

		
		%%%% delete redundant bids %%%%
		forall bel( highest_bid(Sender, Level, Dir, Util), bid(AnyAgt, Level, Dir, AnyUtil), Util > AnyUtil)
			do  delete( bid(AnyAgt,Level,Dir,AnyUtil)  )
			+ delete( highest_bid(AnyAgt,Level,Dir,AnyUtil) ).
		
		% delete bids if there is no auction for it
		forall bel( bid(Agt, Level, Dir, Util), not(auction(Level, Dir)) )
			do delete( bid(Agt, Level, Dir, Util) ).
		% delete hasbid if there is no auction for it
		forall bel( hasBid(Agt, Level, Dir), not(auction(Level, Dir)) )
			do delete( hasBid(Agt, Level, Dir) ).
			
		
		% if more than one highest bids exist, delete the redundant ones and keep only one left (may receive during the same cycle)
		if bel( auction(Level, Dir), hasSameBid(Level, Dir), bid(Agt, Level, Dir, Util), bid(OtherAgt, Level, Dir, OtherUtil), 
					highest_bid(Agt, Level, Dir, Util), highest_bid(OtherAgt, Level, Dir, Util), OtherAgt \= Agt, OtherUtil = Util, selectAgt([Agt, OtherAgt], AnyAgt))
			then delete( bid(AnyAgt, Level, Dir, Util) )
			+ delete( highest_bid(AnyAgt, Level, Dir, Util) )
			+ log(deleted).
		

		% assign task to the agent who bid the highest
		forall bel( highest_bid(Receiver, Level, Dir, Util), bid(Receiver, Level, Dir, Util), Util > 0, not(hasSameBid(Level, Dir)),
				agent(Receiver), not(me(Receiver)), not(notAllBid(Level,Dir)) )
			do (Receiver).sendonce( task(Level, Dir) )
				+ insert( served(Level, Dir) )
				+ delete( highest_bid(Receiver, Level, Dir, Util) )
				+ delete( bid(Receiver, Level, Dir, Util) )
				+ delete( sent(Receiver, task(Level, Dir)) ).
		
				
		% delete hasBid information when one auction has been served
		forall bel( served(Level, Dir), agent(Agt), not(me(Agt)) )
			do delete( hasBid(Agt, Level, Dir) ).
		

		
		
	}
}