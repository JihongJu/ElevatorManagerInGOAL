init module{
	knowledge{
		
		% auction
		auction(Level, Dir) :- fButtonOn(Level,Dir), not(served(Level,Dir)).
		
		% agent X bids higher than agent Y
		higherThan(X, Y, Level, Dir) :- bid(X, Level, Dir, UtilX), bid(Y, Level, Dir, UtilY), X\=Y, UtilX>UtilY, agent(X), agent(Y).
		% exist a bid higher than bid (X, Level,Dir,UtilX))
		existHigherThan(X, Level,Dir,UtilX) :- bid(X, Level, Dir, UtilX), higherThan(_,X,Level,Dir).
		% there does not exist a bid higher than the highest bid
		highest_bid(X, Level,Dir,UtilX) :- auction(Level, Dir), bid(X, Level, Dir, UtilX), not(existHigherThan(X, Level, Dir, UtilX)).
		
		% exist a bid for the auction
		existABid(Level, Dir) :- auction(Level, Dir), bid(AnyAgt, Level, Dir, AnyUtil).
		
		% exists one agent not send bidding request
		notAllReqSent(Level, Dir) :- auction(Level, Dir), agent(Agt), not(me(Agt)), not(requestSent(Agt, Level, Dir)).
		
		% exists one agent not bid
		notAllBid(Level, Dir) :- auction(Level, Dir), agent(Agt), not(me(Agt)), not(hasBid(Agt, Level, Dir)).
		
		% Count current number of tasks
		hasSameBid(Level, Dir) :- aggregate_all(count, bid(_,Level,Dir,Util), Count), Count \= 1.
		
		% set agent priority for task assignment
		%% choose(List, Elt) - chooses a random element
		%% in List and unifies it with Elt.
		selectAgt([], []).
		selectAgt(List, Elt) :- length(List, Length), random(0, Length, Index), nth0(Index, List, Elt).
		
		%%%%%%%%%%% doesn't work properly
 		% new an auction if there is does not exist
%		auction([X], Level, Dir) :- bid(X,Level,Dir,UtilA), not(auction([_], Level, Dir)).
%		auction([X], Level, Dir) :- bid(X,Level,Dir,UtilA), not(auction([_|_], Level, Dir)).
 		% add a bid to an exist auction
 		% If there is already one bid in the auction, put the higher bid in front of the lower one
%		auction([X,Y], Level, Dir) :- auction([Y], Level, Dir), not(X=Y), higherThan(X,Y,Level,Dir). 	% do not need bid(Y,Level,Dir,UtilY),
%		auction([Y,X], Level, Dir) :- auction([Y], Level, Dir), not(X=Y), higherThan(Y,X,Level,Dir). 	% bid(X,Level,Dir,UtilX) here
 		% If there are more than one bids, compare the new bid and the head of the old list (which is the highest) 
 		% and make the higher one as the new head
%		auction([X,H|T], Level, Dir) :- auction([H|T], Level, Dir), not(member(X,[H|T])), higherThan(X,H,Level,Dir).
%		auction([H,X|T], Level, Dir) :- auction([H|T], Level, Dir), not(member(X,[H|T])), higherThan(H,X,Level,Dir).
 		% find the highest bid of a auction (take the head)
%		highest_bid(X, Level, Dir, UtilX) :- auction([X],Level,Dir), bid(X,Level,Dir,UtilX).
%		highest_bid(X, Level, Dir, UtilX) :- auction([X|_],Level,Dir), bid(X,Level,Dir,UtilX).
 		%%%%%%%%%%%% end

		
		
	}
	beliefs{
		atFloor(1).
		dir(down).
		served(1,down).
		
	}
	goals{
				
	}
}

main module{
	program {
		

	}
}

event module {
	program {
		%%%%% Communicating Processing %%%%%
		
		% update beliefs from elevator agents' percepts
		%%%%%%%%%%%%%%%%%%%%%%%%%%%% not used by now
		% insert "Sender is at floor Lever" whenever received from Sender at floor Level and delete whenever
		% received from Sendor not at floor Level
		% agtAtFloor True if agent Agt is at floor Level.
%		forall bel( received(Sender, atFloor(Level)), not(agtAtFloor(Sender, Level)) ) 
%			do insert( agtAtFloor(Sender, Level) )
%			+ delete( received(Sender, atFloor(Level)) ).	% delete received messages 
					
%		forall bel( agtAtFloor(Sender, Level), received(Sender, not(atFloor(Level))) )
%			do delete( agtAtFloor(Sender, Level) )
%			+ delete( received(Sender, not(atFloor(Level))) ).	% delete received messages
		
		% insert or delete "Level Floor's Dir button is on" when received from elevator agents.
		forall bel( received(Sender, fButtonOn(Level,Dir)) )
			do insert( fButtonOn(Level,Dir) )
			+ delete( received(Sender, fButtonOn(Level,Dir)) ).	% delete received messages 
			
		forall bel(  received(Sender, not(fButtonOn(Level,Dir))) )
			do delete( fButtonOn(Level,Dir) )
			+ delete( received(Sender, not(fButtonOn(Level,Dir))) )	% delete received messages
			+ delete( served(Level, Dir) ).
		
		% update "Sender's doorState" from Old to New
%		forall bel( received(Sender, not(doorState(Old), doorState(New))) ) 
%				do insert( not(elevDoorState(Sender,Old)), elevDoorState(Sender, New) )
%				+ delete( received(Sender, not(doorState(Old), doorState(New))) ).	% delete received messages //TODO probably don't need
		
		% insert or delte "Sender is going direction Dir" when received from elevators
%		forall bel( received(Sender, dir(Dir)), not(agtDir(Sender, Dir)) )
%			do insert( agtDir(Sender,Dir) )
%			+ delete(received(Sender, dir(Dir))).	% delete received messages
%		forall bel( agtDir(Sender, Dir), received(Sender, not(dir(Dir))) )
%			do delete( agtDir(Sender,Dir) )
%			+ delete( received(Sender, not(dir(Dir))) ). 	% delete received messages //TODO probably don't need
			
		%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Bids Management
		% send auction. requestSent help manage bidding request and hasbid help handle response from the elevators
		forall bel( agent(Receiver), not(me(Receiver)), auction(Level, Dir), not(requestSent(Receiver, Level, Dir)), not(hasBid(Sender, Level, Dir) ) )
			do (Receiver).sendonce(please_bid(Level,Dir))
			+ insert( requestSent(Receiver, Level, Dir) )
			+ delete( sent(Receiver, please_bid(Level,Dir)) ).
		
		% send the auction for another time if all the elevators bid with Util less than or equal to 0
		forall bel( highest_bid(Agt, Level, Dir, Util), bid(Agt, Level, Dir, Util), Util =< 0, not(notAllBid(Level,Dir)),  agent(Receiver), not(me(Receiver)), not(served(Level, Dir)) )
			do (Receiver).sendonce(please_bid_once_again(Level,Dir))
			+ insert( requestSent(Receiver, Level, Dir) )
			+ delete( sent(Receiver, please_bid_once_again(Level,Dir)) ).
		
		forall bel( received(Sender, contd(Level, Dir)) )
			do delete( served(Level, Dir) )
			+ delete( received(Sender, contd(Level, Dir)) ).

		
		%%%%% receive bids
		
		% accept the first bid for an auction
		forall bel( received(Sender, bid(Level, Dir, Util)), auction(Level, Dir), not(existABid(Level,Dir)), not(me(Sender)) )
			do delete( received(Sender, bid(Level, Dir, Util)) )
			+ insert( bid(Sender, Level, Dir, Util) )
			+ insert( hasBid(Sender, Level, Dir) )
			+ delete( requestSent(Sender, Level, Dir) ).
			
		% accept bid with different utility from the previous one
		forall bel( received(Sender, bid(Level, Dir, Util)), auction(Level, Dir), bid(OtherSender, Level, Dir, OtherUtil), 
				Util \= OtherUtil, not(me(Sender)) )
			do delete( received(Sender, bid(Level, Dir, Util)) )
			+ insert( bid(Sender, Level, Dir, Util) )
			+ insert( hasBid(Sender, Level, Dir) )
			+ delete( requestSent(Sender, Level, Dir) ).

		% reject bid with the same utility as the previous one
		forall bel( received(Sender, bid(Level, Dir, Util)), auction(Level, Dir), bid(OtherSender, Level, Dir, OtherUtil), Util = OtherUtil, not(me(Sender)) )
			do delete( received(Sender, bid(Level, Dir, Util)) )
			+ insert( hasBid(Sender, Level, Dir) )
			+ delete( requestSent(Sender, Level, Dir) ).
		
		% reject bid when auction has been closed
		forall bel( received(Sender, bid(Level, Dir, Util)), not(auction(Level, Dir)) )
			do delete( received(Sender, bid(Level, Dir, Util)) )
			+ delete( requestSent(Sender, Level, Dir) ).




		
%		%% find highest bid
%		forall bel( auction(Level, Dir), bid(Agt, Level, Dir, Util), not(existHigherThan(Agt, Level, Dir, Util)) )
%			do insert( highest_bid(Agt, Level, Dir, Util) ).
		
		%% delete redundant bids
		forall bel( highest_bid(Sender, Level, Dir, Util), bid(AnyAgt, Level, Dir, AnyUtil), Util > AnyUtil)
			do  delete( bid(AnyAgt,Level,Dir,AnyUtil)  )
			+ delete( highest_bid(AnyAgt,Level,Dir,AnyUtil) ).
		
		
		forall bel( bid(Agt, Level, Dir, Util), not(auction(Level, Dir)) )
			do delete( bid(Agt, Level, Dir, Util) ).
		
		forall bel( hasBid(Agt, Level, Dir), not(auction(Level, Dir)) )
			do delete( hasBid(Agt, Level, Dir) ).
			
		
		% if more than one highest bids exist, delete the redundant ones and keep only one left (may receive during the same cycle)
		if bel( auction(Level, Dir), hasSameBid(Level, Dir), bid(Agt, Level, Dir, Util), bid(OtherAgt, Level, Dir, OtherUtil), 
					highest_bid(Agt, Level, Dir, Util), highest_bid(OtherAgt, Level, Dir, Util), OtherAgt \= Agt, OtherUtil = Util, selectAgt([Agt, OtherAgt], AnyAgt))
			then delete( bid(AnyAgt, Level, Dir, Util) )
			+ delete( highest_bid(AnyAgt, Level, Dir, Util) )
			+ log(deleted).

%		forall bel( auction(Level, Dir), hasSameBid(Level, Dir))
%			do print( hasSameBid(Level, Dir) ).
		
		

		% assign task to the agent who bid the highest
		forall bel( highest_bid(Receiver, Level, Dir, Util), bid(Receiver, Level, Dir, Util), Util > 0, not(hasSameBid(Level, Dir)),
				agent(Receiver), not(me(Receiver)), not(notAllBid(Level,Dir)) )
			do (Receiver).sendonce( task(Level, Dir) )
				+ insert( served(Level, Dir) )
				+ delete( highest_bid(Receiver, Level, Dir, Util) )
				+ delete( bid(Receiver, Level, Dir, Util) )
				+ delete( sent(Receiver, task(Level, Dir)) ).
		
				
		% delete hasBid information when one auction has been served
		forall bel( served(Level, Dir), agent(Agt), not(me(Agt)) )
			do delete( hasBid(Agt, Level, Dir) ).
		
		% Issue: Ghost 4th Floor	
		% manager did not receive fButtonOn(4,down) from the elevator even though it was sent.
		% //TODO Double check the request from passenger (fButtonOn) is served or not
		% fButtonOn(Level,Dir), served(Level,Dir), requestSent(Level,Dir)
		

				
		
	}
}