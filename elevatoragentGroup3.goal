init module {
	knowledge{
		% onRoute succeeds when Level is in the current direction Dir relative to the floor the agent is at.
		% Note that onRoute only succeeds when the elevator car is "docked", i.e. atFloor(Here) succeeds for
		% some floor (see also the belief section).
%		onRoute(Level, Dir) :- atFloor(Here), dir(Dir), Diff is Level-Here, (Diff<0 -> Dir=down; Dir=up).

		% trying to fix the 'official' bug in the Assignment 1: onRoute only succeeds when the elevator car is "docked"
		% use percept(carPosition(Here)) instead of atFloor(Here)
		onRoute(Level, Dir) :- percept(carPosition(Here)), dir(Dir), Diff is Level-Here, (Diff<0 -> Dir=down; Dir=up).
		
		% distance calculator
		distance(Level, Dist) :- percept(carPosition(Here)), Dist is abs(Here-Level).
		
		% current available space
		space(M) :- people(P), capacity(C), M is C-P.
		
		% existABid
		existABid(Level, Dir) :- bid(Level, Dir, AnyUtil).
		
		% Count current number of tasks
		numOfTask(Count) :- aggregate_all(count, task(_,_), Count).
		
		
		% Utility assignment -> Now move to main module
%		bid(Level, Dir, Util) :- task(Level,Dir), random_between(0,10, Util).

	}
	beliefs{
		% The direction that will be shown to the people at the next stop.
		% This remains the intended direction of movement until there are no more
		% planned stops in that direction.
		atFloor(1).
		dir(down).
		% Initially, it is unknown whether doors are open or closed.
		doorState(closed).
		% Initially, no people in the elevator.
		people(0).
	}
	goals{
		% atFloor(1), dir(up).
	}
	actionspec{
		% The action goto(Level, Dir) moves the elevator car to floor Level. It can
		% only be performed if the elevator car is docked and not moving, i.e.,
		% atFloor(Here) holds for some Here.
		% When the elevator arrives at the requested floor, the Dir light will turn on.
		goto(Level, Dir) {
		   pre{ atFloor(Here), dir(DirNow), doorState(closed) }
		   post{ not(dir(DirNow)), dir(Dir) }
		}
	}
}
	
main module {
	program {
		% Goto the nearest floor that the agent wants to go to.
		if a-goal( atFloor(Level), dir(Dir) ),
			bel( atFloor(Here), Distance is abs(Level-Here) ),
		    not(a-goal( atFloor(OtherLevel),
				OtherDistance is abs(OtherLevel-Here), OtherDistance<Distance) )
		then goto(Level, Dir).
	}
}
	
event module {
	program {
		%%%%% Communication Processing %%%%%

		
		% Percepts
		%%%%%%%%%%%%%%%%%%%%%%%%%%%% Not used by now
		% Send "I am at floor Level" or "I am NOT at floor level" to manager when percepts atFloor(Level) changes
%		forall bel( agent(manager), not(me(manager)), percept(atFloor(Level)), not(atFloor(Level)) )
%			do (manager).sendonce(atFloor(Level)).
%		forall bel( agent(manager), not(me(manager)), atFloor(Level), not(percept(atFloor(Level))) )
%			do (manager).sendonce(not(atFloor(Level))).
		
		% Send "Level floor's Dir button is on" or "Level floor's Dir button is NOT on" to manager when percepts fButtonOn(Level,Dir) changes
		forall bel( percept(fButtonOn(Level,Dir)), not(fButtonOn(Level,Dir)), agent(manager) )
			do insert( fButtonOn(Level,Dir) )
			+ (manager).sendonce(fButtonOn(Level,Dir))
			+ delete( sent(manager, fButtonOn(Level,Dir)) ).
			
		forall bel( fButtonOn(Level,Dir), not(percept(fButtonOn(Level,Dir))), agent(manager)  )
			do delete( fButtonOn(Level,Dir) )
			+ (manager).sendonce(not(fButtonOn(Level,Dir)))
			+ delete( sent(manager, not(fButtonOn(Level,Dir))) ).
		
		forall bel( fButtonOn(Level, Dir), capacity(C), people(P), P = C, atFloor(Level), dir(Dir) )
			do (manager).sendonce(contd(Level, Dir))
			+ delete( sent(manager, contd(Level, Dir)) ).
		% , doorState(opened)
		
		% Send doorState to manager when it changes
%		forall bel( percept(doorState(New)), doorState(Old) ) do (manager).sendonce( not(doorState(Old)), doorState(New) ).
		
		% Send "I am going Dir direction" or "I am NOT going Dir direction" to manager when dir(Dir) changes
%		forall bel( agent(manager), not(me(manager)), percept(dir(Dir)), not(dir(Dir)) ) do (manager).sendonce(dir(Dir)).
%		forall bel( agent(manager), not(me(manager)), dir(Dir), not(percept(dir(Dir))) ) do (manager).sendonce(not(dir(Dir))).
		
		
		%%%%%%%%%%%%%%%% Bid Management and Utility Assignment
		
		% //TODO fButtonOn onRoute, if it is already in goal, do not insert
		forall bel( fButtonOn(Level, Dir), onRoute(Level, Dir), distance(Level, Dist), space(M), numOfTask(T), Util is (M*(10)-(Dist+T*(5))), not(existABid(Level, Dir)) ) , not(goal( atFloor(Level),dir(Dir) ))
			do insert( bid(Level, Dir, Util) ).
		% if there exists a bid, update it
		forall bel( fButtonOn(Level, Dir), onRoute(Level, Dir), distance(Level, Dist), space(M), numOfTask(T), Util is (M*(10)-(Dist+T*(5))), bid(Level, Dir, AnyUtil), Util \= AnyUtil ) , not(goal( atFloor(Level),dir(Dir) ))
			do insert( bid(Level, Dir, Util) )
			+ delete( bid(Level, Dir, AnyUtil) ).
		

		% Problem discussed in Assignment 1 here: When the agent is idle, it will serve an arbitary request. In the RandomSeed
		% '6353' case, it is fButtonOn(9,down). Then the agent will 'goto' Level 9 as it is the only goal it has. The agent will
		% not stop by the other floor even thoug there is a request on route and it is added to the goal because it is executing
		% goto action.
		% //TODO arbitary service
		forall bel( fButtonOn(L,D), atFloor(Any), doorState(closed), distance(L, Dist), floorCount(F), Util is (F-Dist), not(existABid(Level, Dir)) ), not(goal( atFloor(AnyL) ))
			do insert( bid(L, D, Util) ).
		% if there exists a bid, update it
		forall bel( fButtonOn(L,D), atFloor(Any), doorState(closed), distance(L, Dist), floorCount(F), Util is (F-Dist), bid(L,D,AnyUtil), Util \= AnyUtil ), not(goal( atFloor(AnyL) ))
			do insert( bid(L, D, Util) )
			+ delete( bid(L,D,AnyUtil) ).
			
		% if arriving floor 1 and not full then accept people there. Fix ignorance problem due to direction conflict.
		if bel( atFloor(1), dir(down), fButtonOn(1,up), capacity(C), not(people(C)), Util is 100, not(existABid(1, up)) )
			then insert( bid(1, up, Util) ).
		% if there exists a bid, update it
		if bel( atFloor(1), dir(down), fButtonOn(1,up), capacity(C), not(people(C)), Util is 100, bid(1, up, AnyUtil), Util \= AnyUtil )
			then insert( bid(1, up, Util) )
			+ delete( bid(1, up, AnyUtil) ).
		
		% if arriving floor N and not full then accept people there
		if bel( floorCount(N), atFloor(N), dir(up), fButtonOn(N,down), capacity(C), not(people(C)), Util is 100, not(existABid(N, down)) )
			then insert( bid(N, down, Util) ).
		% if there exists a bid, update it
		if bel( floorCount(N), atFloor(N), dir(up), fButtonOn(N,down), capacity(C), not(people(C)), Util is 100, bid(N, down, AnyUtil), Util \= AnyUtil )
			then insert( bid(N, down, Util) )
			+ delete( bid(N, down, AnyUtil) ).
		
		
		% delete redundant bids
		forall bel( bid(Level, Dir, Util), bid(Level, Dir, AnyUtil), AnyUtil < Util )
			do delete( bid(Level, Dir, AnyUtil) ).
		
		% delete bids for finished tasks
		forall bel( bid(Level, Dir, AnyUtil), not(fButtonOn(Level, Dir)) )
			do delete( bid(Level, Dir, AnyUtil) ).
			
		%%%%%%%%%%%%%%% Bid Sending as manager's request
		% send the bid as the manager's request 
		forall bel( received(manager, please_bid(Level, Dir)), bid(Level, Dir, Util) )
			do (manager).sendonce(bid(Level, Dir, Util))
			+ delete( received(manager, please_bid(Level, Dir)) )
			+ delete( bid(Level, Dir, Util) )
			+ delete( sent(manager, bid(Level, Dir, Util)) ).
		
		% send 0 utility bid and delete bidding request from manager if there is no bid for this request
		forall bel( received(manager, please_bid(Level, Dir)), not(existABid(Level, Dir)) )
			do (manager).sendonce(bid(Level, Dir, 0))
			+ delete( received(manager, please_bid(Level, Dir)) )
			+ delete( sent(manager, bid(Level, Dir, 0)) ).
		
		% send the bid once again as the manager's request 
		forall bel( received(manager, please_bid_once_again(Level, Dir)), bid(Level, Dir, Util) )
			do (manager).sendonce(bid(Level, Dir, Util))
			+ delete( received(manager, please_bid_once_again(Level, Dir)) )
			+ delete( bid(Level, Dir, Util) )
			+ delete( sent(manager, bid(Level, Dir, Util)) ).
		
		% send nothing if no bid when receive bidding request once again
		forall bel( received(manager, please_bid_once_again(Level, Dir)), not(existABid(Level, Dir)) )
			do (manager).sendonce(bid(Level, Dir, 0))
			+ delete( received(manager, please_bid_once_again(Level, Dir)) )
			+ delete( sent(manager, bid(Level, Dir, 0)) ).
		

		%%%%%%%%%%%%%%%% Goal receiving
		% receive task (or task) from the manager
		forall bel( received(manager, task(Level, Dir)) )
			do delete( received(manager, task(Level, Dir)) )
			+ adopt( atFloor(Level), dir(Dir) )
			+ insert( task(Level, Dir) ).
		
		% delete completed tasks
		forall bel( atFloor(Level), dir(Dir), Level \= 1, Dir \= down ) 
			do delete( task(Level, Dir)).
		
		% test
%		forall bel( numOfTask(N) )
%			do print( numOfTask(N) ).
		
		
		%%%%% Percept Processing %%%%%

		
		% The atFloor(Level) percept is received only when elevator has stopped at a floor Level.
		forall bel( percept(atFloor(Level)), not(atFloor(Level)) ) do insert( atFloor(Level) ).
		forall bel( atFloor(Level), not(percept(atFloor(Level))) ) do delete( atFloor(Level) ).
				
		% The fButton(Level,Dir) percept indicates that the up or down (Dir) button on floor Level has been pressed.
%		forall bel( percept(fButtonOn(Level,Dir)), not(fButtonOn(Level,Dir)) ) do insert( fButtonOn(Level,Dir) ).
%		forall bel( fButtonOn(Level,Dir), not(percept(fButtonOn(Level,Dir))) ) do delete( fButtonOn(Level,Dir) ).
		
		% The eButtonOn(Level) percept indicate the level button in the elevator has been pressed		
		forall bel( percept(eButtonOn(Level)), not(eButtonOn(Level)) ) do insert( eButtonOn(Level) ).
		forall bel( eButtonOn(Level), not(percept(eButtonOn(Level))) ) do delete( eButtonOn(Level) ).
		
		% The doorState percept is received only if the door state has changed.
		% So we do not need to check whether the New value is different from the Old value to avoid unnecessary updates.
		forall bel( percept(doorState(New)), doorState(Old) ) do insert( not(doorState(Old)), doorState(New) ).
		
		% People load. This percept is only sent when the number N has just changed.
		forall bel( percept(people(New)), people(Old) ) do insert( not(people(Old)), people(New) ).
		
		% Capacity.This percept is only sent once at the start of a simulation.
		if bel( percept(capacity(C)) ) then insert( capacity(C) ).
		
		% Number of floors. This percept is only sent once at the start of a simulation.
		if bel(percept(floorCount(N))) then insert(floorCount(N)).
		
		
		


		%%%%% Goal Management %%%%%

		% The elevator agent changes its plans only while it is docked, i.e., at a floor
		% and not moving.
		
		% Adopt new stops that are on this agent's route.
		%forall bel( fButtonOn(Level, Dir), onRoute(Level, Dir) ) do adopt( atFloor(Level), dir(Dir) ).
				
		% The eButton(Level) percept is received when the elevator button on floor Level has been pressed.
		% In that case, the agent will adopt a goal to service that floor. It is ASSUMED that a button for a floor is
		% pressed that is "on route", i.e. in the direction the elevator is currently travelling.
		forall bel( percept(eButtonOn(Level)), dir(Dir) ) 
			do adopt( atFloor(Level), dir(Dir) )
			+ insert( task(Level, Dir) ).

		% If there are no current goals to pursue, then adopt a goal to service an arbitrary floor for
		% which a floor button has been pressed that is not already being serviced.
%		if bel( atFloor(Any) ), not(goal( atFloor(AnyL) )), bel( fButtonOn(L,D), doorState(closed) )
%			then adopt( atFloor(L), dir(D) ).
	}
}